###Basis

**ToString**

Die Methode `toString()` wird verwendet, um Objekte als Zeichenkette darzustellen. Standardmäßig gibt sie nur den Klassennamen und die Speicheradresse zurück. Wenn du die Methode überschreibst, kannst du eine benutzerdefinierte Darstellung des Objekts liefern.

**Beispiel:**
```java
@Override
public String toString() {
    return "Bruch: " + zaehler + "/" + nenner;
}
```

**Bruchzahlen als Objekte**

Brüche können in Java als Objekte durch die Klasse `BruchZahl` dargestellt werden. Ein Bruch hat einen Zähler und einen Nenner. Du kannst dann mit diesen Objekten mathematische Operationen wie Addition, Subtraktion, Multiplikation und Division durchführen.

**Beispiel:**
```java
public class BruchZahl {
    private int zaehler;
    private int nenner;

    public BruchZahl(int zaehler, int nenner) {
        if (nenner == 0) throw new ArithmeticException("Nenner darf nicht null sein!");
        this.zaehler = zaehler;
        this.nenner = nenner;
    }

    public BruchZahl addiere(BruchZahl anderer) {
        int neuerZaehler = this.zaehler * anderer.nenner + anderer.zaehler * this.nenner;
        int neuerNenner = this.nenner * anderer.nenner;
        return new BruchZahl(neuerZaehler, neuerNenner);
    }
}
```

---
+---------------------------------------------------------------+
###Kunde

**Toolbox**

Eine Toolbox ist eine Sammlung von wiederverwendbaren Hilfsmethoden. Sie ist modular und hilft bei Aufgaben wie mathematischen Berechnungen oder Formatierungen.

**Beispiel für eine einfache Toolbox:**
```java
public class Toolbox {
    public static int addiere(int a, int b) {
        return a + b;
    }
}
```

**`==` und `equals()`**

- `==` vergleicht, ob zwei Referenzen auf dasselbe Objekt zeigen.
- `equals()` vergleicht, ob der Inhalt von zwei Objekten gleich ist.

**Beispiel für `equals()`-Methode:**
```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;
    Person person = (Person) obj;
    return name.equals(person.name);
}
```

**toString für `int` zu `String`**

Um eine `int`-Zahl in einen String umzuwandeln, kannst du `Integer.toString()` verwenden.

**Beispiel:**
```java
int zahl = 123;
String str = Integer.toString(zahl);  // Wandelt die Zahl 123 in den String "123" um
```

---
+---------------------------------------------------------------+
###Brüche als Objekte

**Brüche als Objekte**

Ein Bruch wird in Java durch die Klasse `BruchZahl` als Objekt dargestellt, das Zähler und Nenner enthält. Mit Methoden wie `addiere()` kannst du mathematische Operationen durchführen.

**Beispiel für Addition:**
```java
BruchZahl bruch1 = new BruchZahl(1, 2);   // 1/2
BruchZahl bruch2 = new BruchZahl(1, 3);   // 1/3
BruchZahl ergebnis = bruch1.addiere(bruch2); // Ergebnis: 5/6
```
+---------------------------------------------------------------+
### Immutable Klasse Konzept

**Konstruktor**

Der Konstruktor stellt sicher, dass der Nenner nie null ist, da eine Division durch null nicht erlaubt ist. Wenn der Nenner null ist, wird eine `ArithmeticException` geworfen.

**Beispiel für den Konstruktor:**
```java
public BruchZahl(int zaehler, int nenner) {
    if (nenner == 0) throw new ArithmeticException("Nenner darf nicht null sein!");
    this.zaehler = zaehler;
    this.nenner = nenner;
}
```
+---------------------------------------------------------------+
**Mathematische Operationen**

Methoden wie `addiere()`, `subtrahiere()`, `multipliziere()` und `dividiere()` berechnen den neuen Zähler und Nenner.

**Beispiel für Division:**
```java
public BruchZahl dividiere(BruchZahl anderer) {
    if (anderer.zaehler == 0) throw new ArithmeticException("Division durch null!");
    int neuerZaehler = this.zaehler * anderer.nenner;
    int neuerNenner = this.nenner * anderer.zaehler;
    return new BruchZahl(neuerZaehler, neuerNenner);
}
```
+---------------------------------------------------------------+
**Kürzen eines Bruchs**

Ein Bruch wird durch den größten gemeinsamen Teiler (ggT) gekürzt.

**Beispiel für das Kürzen:**
```java
public BruchZahl kuerze() {
    int ggT = berechneGGt(this.zaehler, this.nenner);
    this.zaehler /= ggT;
    this.nenner /= ggT;
    return this;
}
```

**Fehlerbehandlung**

Bei einer Division durch null wird eine `ArithmeticException` geworfen.

---
+---------------------------------------------------------------+
### Kapselung

**Klasse**

Eine Klasse ist eine Vorlage für Objekte. Sie definiert die Daten (Felder) und das Verhalten (Methoden) der Objekte.

**Beispiel für eine Klasse:**
```java
public class Person {
    private String name;
    private int alter;

    public Person(String name, int alter) {
        this.name = name;
        this.alter = alter;
    }
}
```
+---------------------------------------------------------------+
**Kapselung**

Kapselung schützt die Daten eines Objekts vor unbefugtem Zugriff. Mit Getter- und Setter-Methoden kannst du auf die Felder zugreifen oder sie ändern.

**Beispiel für Getter und Setter:**
```java
public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}
```
+---------------------------------------------------------------+
**Fortgeschrittene Kapselung**

Es gibt auch spezielle Initialisierer, die bei der Objektinitialisierung helfen, sowie innere Klassen, die auf Felder und Methoden der äußeren Klasse zugreifen können.

---
+---------------------------------------------------------------+
### HashSet vs. TreeSet

- **HashSet:** Schneller beim Suchen und Hinzufügen von Elementen (O(1)), jedoch ohne garantierte Reihenfolge.
- **TreeSet:** Sortiert die Elemente, ist aber langsamer bei der Suche und beim Hinzufügen (O(log n)).

**Beispiel für ein HashSet:**
```java
Set<String> set = new HashSet<>();
set.add("Apfel");
set.add("Banane");
set.add("Kirsche");
```

---
+---------------------------------------------------------------+
### ArrayList vs. LinkedList

- **ArrayList:** Bietet schnellen Zugriff auf Elemente (O(1)), aber langsames Einfügen und Löschen (O(n)).
- **LinkedList:** Bietet schnelles Einfügen und Löschen (O(1)), aber langsamen Zugriff auf Elemente über den Index (O(n)).

---
+---------------------------------------------------------------+
### Java Sortierung mit `Comparator`

Ein `Comparator` ermöglicht es dir, die Reihenfolge von Objekten nach einer bestimmten Regel festzulegen.

**Beispiel für einen `Comparator`:**
```java
@Override
public int compareTo(Person o) {
    Collator collator = Collator.getInstance(Locale.GERMANY);
    return collator.compare(this.name, o.name);
}
```
+---------------------------------------------------------------+
### Default Konstruktor

Ein Default-Konstruktor ist ein Konstruktor ohne Parameter, der automatisch von der Klasse bereitgestellt wird, wenn kein anderer Konstruktor definiert ist. Er wird verwendet, um ein Objekt mit Standardwerten zu initialisieren.

**Beispiel für einen Default-Konstruktor:**
```java
public class Auto {
    private String marke;
    private int baujahr;

    // Default Konstruktor
    public Auto() {
        this.marke = "Unbekannt";
        this.baujahr = 2000;
    }

    public static void main(String[] args) {
        Auto meinAuto = new Auto();
        System.out.println(meinAuto.marke); // Ausgabe: Unbekannt
        System.out.println(meinAuto.baujahr); // Ausgabe: 2000
    }
}
```
+---------------------------------------------------------------+

### Basisklasse 

- es gibt viele klassen in java die final sind



+---------------------------------------------------------------+
## JFRAME Klasse ist eine möglichkeit ein Java fenster zu erstellen

// Swing - billig schnell cool
// JavaFX - hat sich nicht durchgesetzt


import javax.swing.JFrame;
public class TestMeinFenster {
	public static void main(String[] args) {
		MeinFenster fenster = new MeinFenster();
		fenster.setSize(500, 500 );
		fenster.setVisible(true);
		fenster.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
}

Visueles programmieren ist möglich - hierzu gibz es möglichkeit mit JFrame eine hilfe zu herbeirufen und hier die fenster zu definieren.

Static Variablen wereb nicht serialisiert.



+---------------------------------------------------------------+
### Vererbung II - Serielisierung

1. List
    Geordnet: Elemente in Reihenfolge.
    Duplikate: Erlaubt.
    Zugriff: Über Index (z.B. get(0)).

2. Set
    Ungeordnet: Keine feste Reihenfolge.
    Duplikate: Nicht erlaubt.
    Verwendung: Wenn du nur einzigartige Elemente speichern möchtest.

3. Map
    Schlüssel-Wert-Paare: Jeder Schlüssel ist einzigartig.
    Zugriff: Über Schlüssel (z.B. map.get(key)).
    Duplikate: Erlaubt bei den Werten, aber nicht bei den Schlüsseln.



Serialisierung in Java
    Definition: Umwandlung eines Objekts in eine Byte-Darstellung zur Speicherung oder Übertragung.
    Ziel: Objekte in Dateien oder über Netzwerke speichern.
    Benötigte Schnittstelle: Serializable-Interface.
    Vorteil: Ermöglicht Persistenz und Kommunikation zwischen verschiedenen Systemen.

+---------------------------------------------------------------+

Hierzu haben wir eine universelle Toolbox verwendet, um serialisierbare Objekte zu speichern und zu laden. 
Um mit null-Werten umzugehen, gibt es zwei Ansätze: 
Der erste ist die Verwendung von Optional, der zweite ist, eine eigene Klasse zu schreiben, die NullPointerExceptions vermeidet.

Optional        - ist die empfohlene Java-Klasse zur Handhabung von null-Werten, da sie eine explizite Kontrolle und Fehlervermeidung ermöglicht.
Eigene Klasse   - wäre aufwendiger, aber könnte genutzt werden, um NullPointerExceptions manuell zu vermeiden. 


+---------------------------------------------------------------+
Bei der Deep Copy in Java geht es um Serialisierung: 
Man serialisiert das Objekt (erstellt eine Byte-Kopie) und deserialisiert es anschließend, um eine neue, unabhängige Kopie des Objekts zu erstellen.

Ressourcenmanagement bedeutet, dass Dateien, Streams oder Verbindungen korrekt geöffnet und geschlossen werden.
Verwende close() und dispose() anstelle von finalize(), da diese Methoden sofort aufgerufen werden.

close():       Schließt Ressourcen wie Streams oder Datenbanken. 
Beispiel:      try (FileInputStream fis = new FileInputStream("file.txt")) { }

dispose():     Gibt GUI-Komponenten (z.B. Fenster) in Swing/AWT frei.
Beispiel:      frame.dispose();


+---------------------------------------------------------------+

Es kann aber auch der compiler für den Programmierer übernehmen.
finally block muss aber immer gemacht werden.


Bei Swing wird die Methode dispose() aufgerufen, wenn ein Fenster (z.B. JFrame) geschlossen wird. 
Sie gibt die vom Fenster belegten Ressourcen frei, ohne die Anwendung zu beenden.

Wichtig: dispose() wird für GUI-Ressourcen verwendet, während close() für das Schließen von Streams oder Verbindungen zuständig ist.
Es ist eine grundlegende Entscheidung, ob du ein Fenster mit dispose() schließt oder es einfach unsichtbar machst (z.B. mit setVisible(false)).

dispose() gibt die vom Fenster belegten Ressourcen frei und entfernt es vollständig.
Wenn du das Fenster jedoch nur ausblenden möchtest, ohne die Ressourcen freizugeben, solltest du setVisible(false) verwenden. 
Wichtig ist, dass du nicht einfach das Fenster unsichtbar machst und dann ein neues öffnest, da dies zu unnötigen Ressourcenkosten führen kann.


Es ist eine grundlegende Entscheidung, ob du ein Fenster mit dispose() schließt oder es einfach unsichtbar machst (z.B. mit setVisible(false)).

dispose() gibt die vom Fenster belegten Ressourcen frei und entfernt es vollständig. Wenn du das Fenster jedoch nur ausblenden möchtest, ohne die Ressourcen freizugeben, solltest du setVisible(false) verwenden.
Wichtig ist, dass du nicht einfach das Fenster unsichtbar machst und dann ein neues öffnest, da dies zu unnötigen Ressourcenkosten führen kann.

+---------------------------------------------------------------+
#PROJEKTANFORDERUNGEN:

    Spring Data mit JDBC (Derby):
        Nutze Spring Data JDBC zur Anbindung an eine Derby-Datenbank.
        Implementiere Repositories und verwalte Daten über JdbcTemplate.

    REST API:
        Entwickle eine RESTful API mit Spring Web und implementiere CRUD-Endpunkte mit @RestController.

    Pflichtenheft & Arbeitspakete:
        Erstelle ein Pflichtenheft mit klaren Arbeitspaketen: Datenbankkonfiguration, API-Entwicklung, Tests und Fehlerbehebung.

    Spring:
        Verwende Spring Boot für eine schnelle, wartbare Entwicklung und automatische Konfiguration.

    Troubleshooting:
        Nutze Logging und Testtools (z.B. Postman) zur Fehlerbehebung und zur Sicherstellung der Funktionsfähigkeit.

(Fasade Pattern benutzen) - add. Fabrikmuster (optional)

+---------------------------------------------------------------+
Ein Konstruktor dient der Initialisierung eines Objekts. Er kann Ausnahmen auslösen oder sie behandeln, wenn bei der Initialisierung Fehler auftreten.

+---------------------------------------------------------------+

#Toolbox: Eine Sammlung nützlicher Funktionen, die jedoch aufgrund von Vererbung und komplexen Architekturen schwer zu pflegen sein kann. (Speichern und Laden)

Fabrikmethode: Eine Methode zur Erzeugung von Objekten. Sie stellt eine saubere Alternative zur Toolbox dar, indem sie die Objektinstanziierung kapselt und ermöglicht, 
verschiedene Typen von Objekten zu erzeugen, ohne dass der Aufrufer die genaue Klasse kennen muss. Sie kann auch zur Behandlung von Ausnahmen verwendet werden.

+---------------------------------------------------------------+
#SOLID ist ein Akronym für fünf Prinzipien der objektorientierten Programmierung, die helfen, den Code wartbar, erweiterbar und verständlich zu halten:
    S - Single Responsibility Principle (SRP): Eine Klasse sollte nur eine einzige Aufgabe haben.
    O - Open/Closed Principle (OCP): Eine Klasse sollte offen für Erweiterungen, aber geschlossen für Änderungen sein.
    L - Liskov Substitution Principle (LSP): Objekte einer abgeleiteten Klasse sollten überall dort eingesetzt werden können, wo Objekte der Basisklasse verwendet werden.
    I - Interface Segregation Principle (ISP): Ein Client sollte nicht gezwungen sein, Methoden zu implementieren, die er nicht benötigt.
    D - Dependency Inversion Principle (DIP): Abhängigkeiten sollten von abstrakten Schnittstellen, nicht von konkreten Implementierungen abhängen.

#KISS - Keep it small and stupid
+---------------------------------------------------------------+
#Design Patterns - diese sollten oft frühzeitig in der Entwicklung berücksichtigt werden, besonders wenn du mit komplexeren Klassen oder Systemen arbeitest.
Wenn du eine neue Klasse erstellst, ist es sinnvoll, das passende Designmuster auszuwählen, um Struktur und Wartbarkeit zu gewährleisten.
Es geht darum, eine solide Grundlage zu schaffen, die später einfacher erweitert und gewartet werden kann.

Häufig angewandte Designmuster bei der Erstellung neuer Klassen:
    Factory Pattern:
        Wird verwendet, um Objekte zu erstellen, ohne die exakte Klasse zu kennen (Konstruktor alternative).
        Es bietet eine einheitliche Schnittstelle zur Instanziierung von Objekten.

    Singleton Pattern:
        Wird verwendet, wenn nur eine Instanz einer Klasse existieren soll 
        (z.B. für eine zentrale Konfiguration oder Log-Manager).

    Observer Pattern:
        Wird verwendet, wenn ein Objekt (der "Subject") Änderungen an seinen Zuständen an eine Liste von abhängigen Objekten (die "Observers") kommunizieren muss.

    Strategy Pattern:
        Wird verwendet, um ein Verhalten von einer Klasse zur Laufzeit auszutauschen. 
        Nützlich, wenn du eine Klasse hast, die mehrere Varianten von einem bestimmten Algorithmus implementieren muss.

    Decorator Pattern:
        Wird verwendet, um die Funktionalität eines Objekts zur Laufzeit zu erweitern, ohne die ursprüngliche Klasse zu verändern.
+---------------------------------------------------------------+
Modellierung in Java bezieht sich auf den Prozess, die realen Anforderungen und Konzepte in Softwareobjekte und -strukturen zu übersetzen.
Dabei wird die Geschäftslogik, der Ablauf und die Daten in einer abstrakten Form dargestellt, oft durch Klassen, Objekte und deren Beziehungen. 
Ziel der Modellierung ist es, eine klare und verständliche Repräsentation des Systems zu schaffen, die die Grundlage für die Implementierung bildet.
+---------------------------------------------------------------+
In Java erfolgt Modellierung typischerweise durch:
    Klassen und Objekte (Datenstruktur und Verhalten),
    Vererbung (Gemeinsamkeiten zwischen Klassen),
    Schnittstellen und abstrakte Klassen (Verträge und allgemeine Struktur),
    Beziehungen (Assoziationen, Aggregationen, Kompositionen).
+---------------------------------------------------------------+
Funktionale Anforderungen:
    Excel-Daten importieren und extrahieren.
    Daten validieren.
    Daten speichern.
    Fehler melden.

Nicht-funktionale Anforderungen:
    	Import dauert max. 2 Sekunden.
    	Fehler sicher abfangen.
    	Einfache Benutzeroberfläche.
    	Sicher und skalierbar.
	Sinnvoll wartbar
+---------------------------------------------------------------+
Prozess zur Ableitung der Architektur aus nicht-funktionalen Anforderungen:
    Identifikation: Definiere nicht-funktionale Anforderungen (z.B. Performance, Sicherheit, Skalierbarkeit).
    Bewertung: Bestimme, wie diese Anforderungen die Architektur beeinflussen.
    Architekturentscheidungen: Wähle passende Architekturansätze (z.B. Caching, Microservices, Verschlüsselung).
    Muster auswählen: Nutze Architekturpattern (z.B. Schichtenarchitektur, Event-Driven).
    Evaluierung: Überprüfe regelmäßig, ob die Architektur die Anforderungen erfüllt und passe sie an.
+---------------------------------------------------------------+

Grales ist ein Open-Source-Framework zur Erstellung von modernen, robusten, skalierbaren und wartbaren Microservices und Webanwendungen.
Es basiert auf Grails, einem beliebten Framework für die Entwicklung von Webanwendungen in Groovy und Java und kombiniert die besten Konzepte von Spring und Grails.
Grales ermöglicht es Entwicklern, Microservices mit minimalem Aufwand zu erstellen, indem es Spring Boot und andere moderne Technologien nutzt.
+---------------------------------------------------------------+
#VERERBUNG MIT INTEFACES
Basisklasse Vererbung, vererbung mit Interfaces:
In Java kann eine Klasse nur von einer einzigen Klasse erben, da Java einfache Vererbung unterstützt.
Das bedeutet, eine Klasse kann nur von einer anderen Klasse direkt erben, aber nicht von mehreren Klassen gleichzeitig.
Dadurch geht Vererbung über mehrere Klassen (wie bei Mehrfachvererbung in anderen Programmiersprachen) verloren.
Wenn du mehrere Funktionen von verschiedenen Klassen nutzen möchtest, kannst du Interfaces verwenden, da eine Klasse mehrere Interfaces implementieren kann.


Main-Klasse:
public class Main {
    public static void main(String[] args) {
        Hund hund = new Hund("Rex");
        hund.essen();
        hund.bellen();
    }
}

Basisklasse (Elternklasse):
public class Tier {
    String name;
    
    public Tier(String name) {
        this.name = name;
    }

    public void essen() {
        System.out.println(name + " isst.");
    }
}

Abgeleitete Klasse (Kindklasse):
public class Hund extends Tier {
    public Hund(String name) {
        super(name);
    }
    public void bellen() {
        System.out.println(name + " bellt.");
    }
}


--wichtig ist die Aussage welche man mit seinem code trifft--
Hint: defensives programmieren 
+---------------------------------------------------------------+

Ein Interface in Java definiert Methoden, die von einer Klasse implementiert werden müssen, ohne die Implementierung festzulegen. Es ermöglicht das Teilen von Funktionalitäten zwischen Klassen, ohne dass diese eine gemeinsame Basisklasse erben müssen.
Beispiele:
+---------------------------------------------------------------+
Serializable und Cloneable sind Marker-Interfaces, d.h. sie definieren keine Methoden. Sie kennzeichnen nur, dass Objekte der Klasse bestimmte Eigenschaften haben (z.B. serialisierbar oder klonbar).
Comparable ist ein Interface, das die Methode compareTo(T o) definiert, die implementiert werden muss, um Objekte zu vergleichen.
+---------------------------------------------------------------+
Marker-Interfaces: Keine Methoden (z.B. Serializable, Cloneable).
Normale Interfaces: Definieren Methoden, die implementiert werden müssen (z.B. Comparable).


+---------------------------------------------------------------+
#POLYMORPHISMUS
In Java kann eine Basisklasse gemeinsamen Code (z.B. für Laden und Speichern von Daten) bereitstellen, den Unterklassen wiederverwenden. 
So wird Redundanz vermieden.

So wie Polymorphismus in Java ermöglicht es, dass Objekte unterschiedlicher Klassen über eine gemeinsame Schnittstelle oder 
Basisklasse aufgerufen werden können, wodurch die Flexibilität erhöht und der Code wiederverwendbar wird.

Eine abstrakte Methode in einer abstrakten Klasse ist wie eine leere Anleitung. 
Sie sagt, was gemacht werden muss, aber nicht, wie es geht. Jede Unterklasse muss diese Anleitung ausfüllen und erklären, wie es geht. 
Man kann keine Objekte von der abstrakten Klasse direkt erstellen, nur von den Unterklassen.

+---------------------------------------------------------------+
#ANONYME INNERE KLASSEN
Anonyme innere Klassen sind eine spezielle Art von inneren Klassen in Java, die keine explizite Klassendeklaration haben. 
Sie werden verwendet, wenn eine Klasse nur einmal benötigt wird, typischerweise bei der Erstellung von Objekten, 
die Instanzen eines Interfaces oder einer abstrakten Klasse sein müssen. Sie werden direkt im Code erstellt, 
ohne eine benannte Klasse zu definieren, was den Code kürzer und lesbarer macht.
+---------------------------------------------------------------+
#INTERFACES
Ein Interface in Java ist eine Sammlung abstrakter Methoden, die von einer Klasse implementiert werden können. 
Ein Interface beschreibt, was eine Klasse tun sollte, aber nicht, wie sie es tun sollte. Interfaces ermöglichen es, 
dass verschiedene Klassen verschiedene Implementierungen für die gleichen Methoden bereitstellen können, wodurch Polymorphismus ermöglicht wird.
Eine Klasse, die ein Interface implementiert, muss alle Methoden des Interfaces implementieren (sofern sie nicht abstrakt ist). 
Ein Interface kann auch Konstanten enthalten, aber keine Instanzvariablen oder Methoden mit einer Implementierung.
+---------------------------------------------------------------+
#KOPPLUNG
Kopplung in Java beschreibt, wie stark Klassen oder Module voneinander abhängen.
Starke Kopplung bedeutet, dass Klassen direkt voneinander abhängig sind. 
Änderungen in einer Klasse erfordern oft Anpassungen in anderen Klassen.
Schwache Kopplung bedeutet, dass Klassen so wenig wie möglich voneinander abhängen, oft durch Abstraktionen wie Interfaces oder Dependency Injection. Dadurch können Änderungen in einer Klasse ohne Auswirkungen auf andere Klassen vorgenommen werden.

Ziel: Eine niedrige Kopplung sorgt für flexibleren, wartbareren und erweiterbaren Code.


+---------------------------------------------------------------+
#SPRING easy Setup - für Jar Java21 - Maven
Lombok 
Spring Web 
Spring Data JPA 
Aapche Derby
pom.xml-Abhängigkeiten:

    Spring Web: Für REST-APIs (spring-boot-starter-web).
    Spring Data JPA: Für Datenbankzugriffe (spring-boot-starter-data-jpa).
    Lombok: Für weniger Boilerplate-Code (Getter, Setter, Konstruktoren).
    Apache Derby: In-Memory-Datenbank für einfache Persistenz (derby).

Hauptklasse:
    Spring Boot startet über @SpringBootApplication Annotation.

Datenbank-Konfiguration:
    In application.properties die JDBC-Verbindung zu Apache Derby konfigurieren.

Entität und Repository:
    Erstelle eine Entität (@Entity) und ein Repository (JpaRepository) für Datenzugriffe.

Controller:
    Erstelle einen einfachen REST-Controller mit Endpunkten (@GetMapping, @PostMapping).

Build & Run:
    Baue das Projekt mit mvn clean install.
    Starte das Projekt mit mvn spring-boot:run

+---------------------------------------------------------------+
#STATIC:
In Java sind statische Klassen nicht direkt erlaubt, aber du kannst eine statische innere Klasse (static nested class) erstellen. 
Eine statische Klasse hat folgende Eigenschaften:

Sie kann ohne Instanziierung der äußeren Klasse verwendet werden.
Alle Mitglieder der statischen inneren Klasse sind auch statisch.
Eine statische innere Klasse kann nicht auf nicht-statische Mitglieder der äußeren Klasse zugreifen.

+---------------------------------------------------------------+
#SINGLETON
Singleton-Entwurfsmuster ist ein Designmuster, das sicherstellt, 
dass eine Klasse nur eine einzige Instanz hat und global darauf zugegriffen werden kann.

In Java kann das Singleton-Muster folgendermaßen umgesetzt werden:

Merkmale des Singleton-Musters:
    Einzelne Instanz: Es gibt nur eine Instanz der Klasse, die über die gesamte Lebensdauer des Programms hinweg verwendet wird.
    Globaler Zugriff: Die Instanz ist über eine statische Methode zugänglich.
    Verhindert Instanziierung: Der Konstruktor ist privat, sodass keine weiteren Instanzen der Klasse erstellt werden können.

+---------------------------------------------------------------+

#FASADE
Das Fassade-Designmuster bietet eine vereinfachte Schnittstelle für ein komplexes Subsystem. 
Anstatt mit vielen einzelnen, komplexen Klassen und deren Methoden zu interagieren, wird eine 
zentrale "Fassade"-Klasse bereitgestellt, die als Vermittler fungiert. Diese Klasse bietet eine vereinfachte 
Schnittstelle und verbirgt die Komplexität der internen Implementierung.
Hauptziele des Fasade-Patterns:

    Vereinfachung der Schnittstelle: Die Fassade bietet eine einfache und einheitliche Schnittstelle, die das Arbeiten mit komplexen Systemen oder Modulen erleichtert.
    Reduzierung der Kopplung: Indem der Benutzer mit der Fassade anstatt direkt mit den komplexen Klassen des Subsystems interagiert, wird die Kopplung zwischen den Modulen reduziert.
    Bessere Wartbarkeit und Erweiterbarkeit: Änderungen am Subsystem können ohne Auswirkungen auf die Benutzer der Fassade durchgeführt werden, da die Fassade die interne Komplexität verbirgt.

+---------------------------------------------------------------+
#EXCEPTIONS

Throwable 			(oberste Klasse, von der alle Fehler und Ausnahmen erben)
  ├── Error 			(Unchecked Exceptions, schwerwiegende Fehler, die nicht vom Programmierer behandelt werden sollten, z. B. `OutOfMemoryError`)
  └── Exception 		(Checked Exception, Ausnahmen, die vom Programmierer behandelt werden können)
       └── RuntimeException 	(Unchecked Exceptions, die bei Programmfehlern auftreten, z. B. `NullPointerException`, `ArrayIndexOutOfBoundsException`)


Checked Exception: 	Wird zur Kompilierzeit überprüft und muss vom Programmierer behandelt (gecatcht) werden.
        			Beispiele: IOException, SQLException, FileNotFoundException, ClassNotFoundException, InterruptedException.

Unchecked Exception: 	Wird zur Laufzeit überprüft und erfordert keine explizite Behandlung zur Kompilierzeit.
        			Beispiele: NullPointerException, ArithmeticException, ArrayIndexOutOfBoundsException, ClassCastException, IllegalArgumentException.
+---------------------------------------------------------------+
Keywords zur Fehlerbehandlung in Java
    try: 	Definiert einen Block von Code, der auf Fehler getestet wird.
    catch: 	Definiert einen Block von Code, der bei Fehlern im try-Block ausgeführt wird.
    finally: 	Wird immer ausgeführt, unabhängig davon, ob eine Ausnahme aufgetreten ist oder nicht.
    throw: 	Ermöglicht das Werfen von benutzerdefinierten Fehlern.
    throws: 	Ermöglicht das Weitergeben von Ausnahmen von einer Methode.
+---------------------------------------------------------------+
Java Global exception handler - Ein globaler Ausnahmebehandler in Java wird mit Thread.setDefaultUncaughtExceptionHandler() gesetzt und fängt alle nicht behandelten Ausnahmen (Uncaught Exceptions) ab.
In einer Standalon Applikation in Java, soll ich mitbekommen, das der Speicher ausgegangen ist.
(Dies soll in Logging mit aufgenommen werden)



+---------------------------------------------------------------+
#TREE SPRING
DRY - Dont Repeat Yourself

Tier (Basisklasse) @Annotation
  ├── Hund (1. Erbende Klasse)
  └── Katze (2. Erbende Klasse) @Annotaion

Hund & Katze (1 & 2 Klasse)
  └──Tierarzt (Verwender)

@Annotation ist eine benutzerdefinierte Annotation, die auf die Basisklasse Tier sowie die abgeleiteten Klassen Hund und Katze angewendet wird. 
Sie könnte z.B. dazu verwendet werden, diese Klassen mit zusätzlichem Metadaten zu versehen, die zur Laufzeit verfügbar sind.
+---------------------------------------------------------------+

#SPRING Boot API

pom.xml-Datei (Project Object Model) in einem Maven-Projekt ist dafür verantwortlich, die Abhängigkeiten, Plugins, Build-Konfigurationen 
und andere Projektmetadaten zu definieren.Sie stellt sicher, dass das Projekt die richtigen Bibliotheken und Tools verwendet, um korrekt 
gebaut und ausgeführt zu werden.

+---------------------------------------------------------------+
#ANNOTATIONS:

    @SpringBootApplication 							– Startet die Spring Boot-Anwendung.
    @Component, @Service, @Repository, @Controller, @RestController 		– Markiert Klassen als Spring Beans.
    @Autowired 									– Automatische Injektion von Abhängigkeiten.
    @Value 									– Injektion von Werten aus der Konfiguration.
    @Configuration, @Bean 							– Konfiguriert Beans und Spring-Einstellungen.
    @RequestMapping, @GetMapping, @PostMapping, @PathVariable, @RequestParam 	– HTTP-Routing und Parameterbindung.
    @Transactional 								– Markiert Methoden für Transaktionsverwaltung.

+---------------------------------------------------------------+

#API's:
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| 
|Protokoll/Architektur      | Beschreibung                                        | Vorteile                               | Nachteile                                                      | Java-Technologie              |
|-------------------------- |-----------------------------------------------------|--------------------------------------- |----------------------------------------------------------------|-------------------------------|
| RPC                       | Aufruf von Funktionen auf entfernten Servern        | Einfacher Funktionsaufruf              | Weniger flexibel, weniger skalierbar                           | Serialisieren und deserial..  |
| CORBA                     | Kommunikation zwischen verteilten Objekten          | Plattform- und sprachunabhängig        | Komplex, schwergewichtig                                       | Java IDL, JacORB              |
| RMI                       | Java-spezifische Remote-Kom durch Methodenaufrufe   | Objektorientiert, in Java integrierbar | Nur für Java geeignet, Performance-Overhead                    | RMI (Remote Method Invocation)|
| SOAP                      | XML-basiertes Protokoll für Webservices             | Unterstützt Sicherheit, Transaktionen  | Hoher Overhead, komplex                                        | JAX-WS                        |
| REST                      | HTTP-basierte Architektur für Webservices(Json)     | Einfach, flexibel, leichtgewichtig     | Weniger standardisiert, keine komplexe Geschäftslogik          | Spring Boot, JAX-RS           |
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|


#CRUD & HTTP METHODS:
|----------------------------------------------------------------------------------------------------------------------------------------------------|
| CRUD    | Bedeutung          | HTTP-Methode (REST)      | Beschreibung                                                                             |
|---------|--------------------|--------------------------|------------------------------------------------------------------------------------------|
| Create  | Erstellen          | POST                     | Erstellen einer neuen Ressource                                                          |
| Read    | Lesen              | GET                      | Abrufen einer Ressource oder einer Liste von Ressourcen                                  |
| Update  | Aktualisieren      | PUT/PATCH                | Aktualisieren einer Ressource (PUT für vollständige, PATCH für teilweise Aktualisierung) |
| Delete  | Löschen            | DELETE                   | Löschen einer Ressource                                                                  |
|----------------------------------------------------------------------------------------------------------------------------------------------------|


#HTTP CODES:
|-----------------------------------------------------------------------------------------------------|
| Code  | Bedeutung                   | HTTP-Methoden / Operationen                                   |
|-------|-----------------------------|---------------------------------------------------------------|
| 200   | OK                          | Erfolgreiche Anfrage (z.B. GET)                               |
| 201   | Created                     | Ressource erfolgreich erstellt (z.B. POST)                    |
| 204   | No Content                  | Erfolgreiche Anfrage ohne Rückgabe von Inhalt (z.B. DELETE)   |
| 400   | Bad Request                 | Ungültige Anfrage (z.B. fehlende oder fehlerhafte Daten)      |
| 401   | Unauthorized                | Nicht autorisiert (fehlende oder ungültige Authentifizierung) |
| 403   | Forbidden                   | Verboten (Zugriff verweigert)                                 |
| 404   | Not Found                   | Ressource nicht gefunden                                      |
| 405   | Method Not Allowed          | Methode nicht erlaubt für die Ressource                       |
| 409   | Conflict                    | Konflikt (z.B. doppelte Daten)                                |
| 415   | Unsupported Media Type      | Nicht unterstützter Medientyp (z.B. falsches Format)          |
| 500   | Internal Server Error       | Serverfehler (interner Fehler)                                |
| 503   | Service Unavailable         | Dienst vorübergehend nicht verfügbar                          |
|-------|-----------------------------|---------------------------------------------------------------|


+---------------------------------------------------------------+
ANFORDERUNGEN BEI SOFTWAREENTWICKLUNG:

Funktionale Anforderungen:
    Verarbeitung von Benutzereingaben: Die Software muss Benutzereingaben verarbeiten und entsprechende Ausgaben liefern.
    Datenbankzugriff: Die Anwendung muss in der Lage sein, mit einer Datenbank zu kommunizieren, z.B. CRUD-Operationen (Create, Read, Update, Delete).
    Authentifizierung und Autorisierung: Benutzer müssen sich einloggen können, und verschiedene Benutzerrollen haben unterschiedliche Berechtigungen.
    Webservice-Integration: Die Anwendung muss mit externen Systemen über RESTful APIs oder SOAP-Webservices kommunizieren.
    Berichtsgenerierung: Erstellen von Berichten oder Analysen aus den gespeicherten Daten.

Nicht-funktionale Anforderungen:
    Leistung (Performance): Die Anwendung muss eine bestimmte Antwortzeit und Durchsatzrate erreichen.
    Zuverlässigkeit: Die Software muss stabil laufen und unter minimalen Ausfällen oder Fehlern betrieben werden können.
    Skalierbarkeit: Die Anwendung muss mit wachsender Nutzerzahl oder Datenmenge skalieren können.
    Sicherheit: Schutz der Daten durch Verschlüsselung, sichere Authentifizierung und Autorisierung.
    Benutzerfreundlichkeit (Usability): Die Software muss einfach und intuitiv zu bedienen sein.
    Wartbarkeit: Der Code muss so geschrieben sein, dass er einfach gewartet und erweitert werden kann.
    Kompatibilität: Die Anwendung muss auf verschiedenen Systemen und Browsern (z.B. cross-platform) funktionsfähig sein.
+---------------------------------------------------------------+

#BULLETPOINTS:
	- Point of no return while PM
	- Clean code
	- Efficiente Speicherverwaltung
	- Cloud, AI
+---------------------------------------------------------------+
#SPRING
Beans: 				Java-Objekte, die vom Spring-Container verwaltet werden und für Geschäftslogik, Datenzugriff oder andere Funktionen verwendet werden. (Faktory wo du Objekt bekommst)
Spring-Container: 		Verwaltet Beans und deren Lebenszyklus, instanziiert sie und führt die Dependency Injection durch.
DI (Dependency Injection): 	Ein Designmuster, bei dem der Spring-Container Abhängigkeiten einer Klasse bereitstellt, anstatt dass die Klasse diese selbst erstellt.

In Spring gibt es 2 arten von Objekte:
- Objekte die nicht gemanaged werden von Kontainer
- Objekte die im Kontainer gemanaged werden 

+---------------------------------------------------------------+
#LOMBOK
Lombok ist eine Java-Bibliothek, die Boilerplate-Code reduziert. 
Mit einfachen Annotationen wie @Getter, @Setter, @ToString und @EqualsAndHashCode generiert Lombok automatisch Code für Getter, Setter, 
Konstruktoren und andere Methoden.  Das spart Entwicklungszeit und macht den Code sauberer. Es funktioniert problemlos mit Java 21, 
solange die richtige Lombok-Version eingebunden ist.

+---------------------------------------------------------------+
#LAMBDA
Lambdas in Java sind anonyme Funktionen, die als Argumente übergeben werden und eine kompakte Syntax für die Implementierung funktionaler Interfaces bieten.
(parameter) -> { // Code block }   BSP: (int a, int b) -> a + b; Lambdas werden häufig in Kombination mit Streams und Methoden wie forEach, map oder filter verwendet, um Funktionen zu übergeben, ohne eine separate anonyme Klasse zu erstellen.

+---------------------------------------------------------------+
#NULLPOINTEREXCEPTION (Lombok bibliothek)
Ein weiteres Konzept in Java ist die konsequente Vermeidung von NullPointerException. Das geht oft durch die Kombination der oben genannten Methoden, insbesondere Optional oder durch präventives Setzen von Standardwerten.

    Optional ist in modernen Java-Versionen die bevorzugte Methode zur Handhabung von null-Werten, da es explizit auf das Fehlen eines Werts hinweist und sichereren Zugriff ermöglicht.
    Wrapper-Klassen sind eine häufige Wahl, wenn du mit primitiven Datentypen und deren null-Werten umgehen musst.
    Das Null Object Pattern hilft, null-Prüfungen zu vermeiden, indem es ein spezielles Objekt anstelle von null verwendet.

+---------------------------------------------------------------+
#GENERATION TYPE TABLE - Warum sollte man GenerationType.TABLE vermeiden?
Die Verwendung von GenerationType.TABLE ist oft nicht empfohlen, und das aus folgenden Gründen:
	Leistungseinbußen: Der Generierungsmechanismus über eine separate Tabelle bedeutet, dass bei jeder ID-Anforderung eine Datenbankabfrage und ein Locking-Vorgang stattfinden müssen. Dies kann zu Leistungsproblemen führen, besonders bei Hochlastsystemen.
	Kollisionsgefahr: Da mehrere Entitäten auf dieselbe Tabelle zugreifen, können durch gleichzeitige Abfragen von mehreren Threads oder Prozessen Deadlocks oder Konflikte entstehen.
	Schlechtere Skalierbarkeit: Eine zentrale Tabelle zur Verwaltung von IDs kann in verteilten Systemen oder bei einer skalierenden Architektur schnell zu einem Bottleneck werden.
	Datenbank-Abhängigkeit: Die Strategie TABLE ist nicht so flexibel wie z. B. SEQUENCE, da sie stark von der zugrunde liegenden Datenbankstruktur abhängt.
	Es ist nicht so portabel wie IDENTITY oder SEQUENCE, die oft in verschiedenen Datenbanken problemlos verwendet werden können.

+---------------------------------------------------------------+
#SQL-SERVER
Ein SQL-Server ist eine Software, die Daten in einer relationalen Datenbank speichert, verwaltet und über SQL-Abfragen zugänglich macht. 
Er ermöglicht es Anwendungen und Clients, Daten zu speichern, abzurufen, zu bearbeiten und zu löschen. SQL-Server bieten auch Funktionen 
wie Transaktionsmanagement, Zugriffskontrolle und Datensicherung.
+---------------------------------------------------------------+

#DATENFORMATE
	XML (Extensible Markup Language): Ein strukturiertes, textbasiertes Format zur Darstellung von Daten in einer hierarchischen Baumstruktur. Häufig verwendet für Konfigurationen und Webdienste.
	JSON (JavaScript Object Notation): Ein leichtgewichtiges, textbasiertes Datenformat, das Daten als Schlüssel-Wert-Paare darstellt. Sehr beliebt für Web-APIs und zwischen Systemen zur Datenübertragung.
	CSV (Comma-Separated Values): Ein einfaches, textbasiertes Format, bei dem Daten durch Kommata getrennt sind. Häufig für tabellarische Daten und den Austausch von Informationen zwischen Tabellenkalkulationen genutzt.
	BIN (Binary): Ein binäres Datenformat, das Daten in einer kompakten Form speichert. Wird oft für Programme, Mediendateien oder proprietäre Formate verwendet, bei denen Effizienz und Geschwindigkeit im Vordergrund stehen.
+---------------------------------------------------------------+

#PAGES & VIEW Konzept
View: Eine virtuelle Tabelle, die eine gespeicherte SQL-Abfrage darstellt und keine eigenen Daten speichert. Wird verwendet, um komplexe Abfragen zu vereinfachen und Daten zu abstrahieren.
Page: Eine physische Speichereinheit in der Datenbank (z.B. 8 KB), in der Daten und Indexe gespeichert werden. Sie hilft der Datenbank, Daten effizient zu verwalten.
+---------------------------------------------------------------+
#INDEX DB
Ein Index in einer Datenbank optimiert die Leseoperationen (Abfragen), indem er schnellen Zugriff auf Daten ermöglicht.

    Optimierung für Lesen: Indizes beschleunigen Suchvorgänge, Filter und Sortierungen, da sie die Daten in einer strukturierten Reihenfolge speichern.
    Auswirkung auf Schreiben: Indizes verlangsamen Schreiboperationen (INSERT, UPDATE, DELETE), weil die Indizes bei jeder Änderung aktualisiert werden müssen.
+---------------------------------------------------------------+
#Liskovsches Substitutionsprinzip - besagt, dass Objekte einer abgeleiteten Klasse in allen Kontexten, in denen Objekte der Basisklasse verwendet werden, ohne Veränderung des Verhaltens eingesetzt werden können.



#Schichten in DB implementierung mit Framework - JAVA Spring 
+---------------------------------------------------------------+
|                    Anwendungsschicht                          |
|                 (Spring Data JPA, JPA API)                    |
|      - API für Persistenzmanagement und Datenbankabstraktion  |
|      - Spring Data JPA vereinfacht den Datenzugriff und bietet|
|        automatische Implementierungen von Repository-Methoden |
|      - JPA API: Spezifikation für die objekt-relationale      |
|        Abbildung von Entitäten und deren Verwaltung           |
+---------------------------------------------------------------+
|                  ORM-Schicht (Datenbankabstraktion)           |
|                                                               |
|                (Hibernate API, JPA Provider)                  |
|      - ORM für die objekt-relationale Abbildung               |
|      - Hibernate kümmert sich um die Abbildung von Objekten   |
|        auf relationale Datenbanken und die Verwaltung der     |
|        Entitäten.                                             |
|      - Diese Schicht bietet eine höhere Abstraktion als JDBC  |
+---------------------------------------------------------------+
|                    Datenzugriffs-Schicht                      |
|                                                               |
|                    (JDBC API, JDBC Template)                  |
|      - API für direkten Zugriff auf relationale Datenbanken   |
|      - Ermöglicht das Ausführen von SQL-Statements direkt auf |
|        der Datenbank                                          |
|      - JDBC Template (Teil von Spring): vereinfacht JDBC-     |
|        Operationen wie das Ausführen von SQL und das Mapping  |
|        von Ergebnissen zu Java-Objekten                       |
+---------------------------------------------------------------+
|                  Java-Laufzeitumgebung                        |
|                         (JDK, JVM)                            |
|      - JDK: Java Development Kit, enthält die Entwicklungs-   |
|        werkzeuge wie Compiler und APIs für die Java-Entwick-  |
|        lung.                                                  |
|      - JVM: Java Virtual Machine, führt den Bytecode aus und  |
|        ermöglicht die Ausführung von Java-Anwendungen auf     |
|        verschiedenen Plattformen.                             |


+---------------------------------------------------------------+
#DB

Das Entity-Relationship-Modell (ER-Modell) dient zur Planung von Datenbanken.

  * Entität:  Ein eindeutig identifizierbares Objekt.
  * Beziehung: Verbindung zwischen Entitäten.
  * Attribut: Eigenschaft einer Entität.

#Kardinalitäten:
  [1:1]  A ↔ B  (Ehemann – Ehefrau)
  [1:n]  A → B  (Museum – Kunstwerke)
  [m:n]  A ⇄ B  (Student – Professor, via Verbindungstabelle)

+---------------------------------------------------------------+
#Pattern from C

* Abstrakte Innere Klasse → Für Vererbung & Struktur.
* Callback (Interface) → Für Event-Handling & Async.
* Delegate (Funktionales Interface) → Für Methodenübergabe.

+---------------------------------------------------------------+
#JDBC Driver Typen

[Typ 1] JDBC-ODBC Bridge:
  - ODBC als Vermittler, ineffizient, nicht empfohlen.

[Typ 2] Native-API-Treiber:
  - Nutzt native Datenbank-APIs, plattformabhängig.

[Typ 3] Netzwerkprotokoll-Treiber:
  - Nutzt spezielles Protokoll, benötigt Middleware-Server.

[Typ 4] Datenbankprotokoll-Treiber:
  - Direkte DB-Kommunikation, schnell, plattformunabhängig.

+---------------------------------------------------------------+
#Java RMI

Remote Method Invocation (RMI) erlaubt Java-Objekten, Methoden über ein Netzwerk
aufzurufen, als wären sie lokal.

  * Nutzt Stubs (Client) & Skeletons (Server).
  * Verwendet Java-Serialization für Objektübertragung.
  * RMI-Registry zur Namensauflösung.

Warum?
Ermöglicht verteilte Anwendungen, bei denen Client & Server auf verschiedenen
Maschinen laufen, aber reibungslos interagieren.

+---------------------------------------------------------------+
#Thread in Java

Ein Thread ist ein separater Ablauf, der parallel zu anderen Code-Teilen läuft.  
Start mit `.start()`.  
Macht Programme schneller, aber Vorsicht bei gemeinsamem Datenzugriff!

+---------------------------------------------------------------+
#Kaskadierung

Verkettung von Elementen: Die Ausgabe eines wird zur Eingabe des nächsten.  
Anwendungen:
   - Elektrotechnik  
   - Management 
   - Informationstechnik   

+---------------------------------------------------------------+
#Swing

Java-Bibliothek für GUIs.  
Basiert auf AWT, erweitert mit flexiblen Komponenten:  
   - `JButton`  
   - `JFrame`  
   - `JPanel`  
Plattformunabhängig & modern!  
+---------------------------------------------------------------+

#Salting 

Salting fuegt einem Passwort vor dem Hashen einen zufaelligen Wert hinzu, 
um es gegen Angriffe wie Rainbow Tables zu schuetzen. Dadurch entstehen 
einzigartige Hashes, selbst bei identischen Passwoertern. Das Salt wird 
mit dem Hash gespeichert, um die Verifizierung zu ermoeglichen.

+---------------------------------------------------------------+

ProcessBuilder & ProcessObject – H2-Server starten
    Tech: Verwendet ProcessBuilder, um externe Prozesse zu starten. Ermöglicht die flexible Übergabe von Parametern, das Umleiten von Ein- und Ausgabeströmen sowie die Steuerung des gestarteten Prozesses.
    Beschreibung: Startet den H2-Datenbankserver als separaten Prozess mit den erforderlichen Argumenten (-tcp, -tcpAllowOthers, -tcpPort 9092). 
    Dadurch kann die Datenbank extern erreichbar gemacht und für mehrere Clients bereitgestellt werden.

Apache Commons Exec – Externe Programme starten (z. B. PDF-Reader)
    Tech: Nutzt Apache Commons Exec als erweiterte Alternative zu ProcessBuilder, die mehr Kontrolle über externe Prozesse bietet, darunter Timeout-Management und asynchrone Prozessverwaltung.
    Beschreibung: Startet eine externe Anwendung, z. B. einen PDF-Reader, mit einer angegebenen Datei. Unter Windows wird start verwendet, unter Linux xdg-open. 
    Optional kann ein bestimmtes Programm (z. B. SumatraPDF.exe) definiert werden, um gezielt bestimmte Anwendungen zu nutzen.

+---------------------------------------------------------------+


OSI-7-Schichten-Modell - Für jede schicht gibt es eigene protokolle:
┌────────────────────────┐  
│    HTTP, FTP, SMTP     │  7. Anwendungsschicht (Application)
├────────────────────────┤   
│   Verschlüsselung, TLS │  6. Darstellungsschicht (Presentation)  
├────────────────────────┤  
│    Sitzungskontrolle   │  5. Sitzungsschicht (Session)
├────────────────────────┤  
│        TCP, UDP        │  4. Transportschicht (Transport)
├────────────────────────┤
│       IP, ICMP, ARP    │  3. Vermittlungsschicht (Network)  
├────────────────────────┤
│     Ethernet, MAC      │  2. Sicherungsschicht (Data Link)  
├────────────────────────┤
│  Kabel, WLAN, Glasfaser│  1. Bitübertragungsschicht (Physical)  
└────────────────────────┘  


+---------------------------------------------------------------+


